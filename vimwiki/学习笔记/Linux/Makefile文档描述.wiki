= Makefile文档描述 =

%toc

== 准备知识 ==
=== 编译 ===
{{{class="brush:text"
    把高级语言书写的代码转换为机器可识别的机器指令。编译高级语言后生成 的指令虽然可被机器识别,但是还不能被执行。
编译时,编译器检查高级语言的语法、函数与变量的声明是否正确。只有所有的语法正确、相关变量定义正确编译器就可以编译
出中间目标文件。通常,一个高级语言的源文件都可对应一个目标文件。目标文件在Linux中默认后缀为“.o” (如“foo.c”的目标
文件为“foo.o”)。
}}}

=== 链接 ===
{{{class="brush:text"
    将多.o文件,或者.o文件和库文件链接成为可被操作系统执行的可执行程序(Linux环境下,可执行文件的格式为“ELF”格式)。
链接器不检查函数所在的源文件,只检查所有.o文件中的定义的符号。将.o文件中使用的函数和其它.o或者库文件中的相关符号
进行合并,对所有文件中的符号进行重新安排(重定位),并链接系统相关文件(程序启动文件等)最终生成可执行程序。链接过程使用
GNU 的“ld”工具。
}}}

=== 静态库 ===
{{{class="brush:text"
    又称为文档文件(Archive File) 。它是多个.o文件的集合。Linux中静态库文件的后缀为“.a”。静态库中的各个成员(.o文件)
没有特殊的存在格式,仅仅是一个.o文件的集合。使用“ar”工具维护和管理静态库。
}}}

=== 共享库 ===
{{{class="brush:text"
    也是多个.o文件的集合,但是这些.o文件时有编译器按照一种特殊的方式生成(Linux中,共享库文件格式通常为“ELF”格式。
共享库已经具备了可执行条件)。模块中各个成员的地址(变量引用和函数调用)都是相对地址。使用此共享库的程序在运行时,
共享库被动态加载到内存并和主程序在内存中进行连接。
    多个可执行程序可共享库文件的代码段(多个程序可以共享的使用库中的某一个模块,共享代码,不共享数据)。另外共享库的成员对象
可被执行(由libdl.so提供支持)。
}}}

== Makefile规则介绍 ==
- 一个简单的Makefile 描述规则组成:

{{{class="brush:bash"
TARGET... : PREREQUISITES...
    COMMAND
    ...
    ...
}}}

=== target(目标) ===
{{{class="brush:text"
    规则的目标。通常是最后需要生成的文件名或者为了实现这个目的而必需的中间过程文件名。可以是.o文件、也可以是最后的可执行程序
的文件名等。另外,目标也可以是一个make执行的动作的名称,如目标“clean”,我们称这样的目标是“伪目标”。
}}}

=== prerequisites(依赖) ===
{{{class="brush:text"
    规则的依赖。生成规则目标所需要的文件名列表。通常一个目标依赖于一个或者多个文件。
}}}

=== command(命令) ===
{{{class="brush:text"
    规则的命令行。是规则所要执行的动作(任意的shell命令或者是可在shell下执行的程序)。它限定了make执行这条规则时所需要的动作。
一个规则可以有多个命令行,每一条命令占一行。
    注意:每一个命令行必须以[Tab]字符开始,[Tab]字符告诉make此行是一个命令行。make按照命令完成相应的动作。这也是书写Makefile中容
易产生,而且比较隐蔽的错误。
    如果要实现：在一个规则的命令中,命令行“cd”改变目录不会对其后的命令的执行产生影响。就是说其后的命令执行的工作目录不会是之前使用“cd”
进入的那个目录。那么就不能把“cd”和其后的命令放在两行来书写。而应该把这两条命令写在一行上,用分号分隔。这样它们才是一个完整的shell命令行。
如:

    foo : bar/lose
        cd bar; gobble lose > ../foo
}}}

== Makefile文件示例 ==
{{{class="brush:bash"
#sample Makefile

edit : main.o kbd.o display.o \
        insert.o search.o files.o utils.o
    cc -o edit main.o kbd.o display.o \
    
insert.o search.o files.o utils.o
main.o : main.c defs.h
    cc -c main.c
kbd.o : kbd.c defs.h
    cc -c kbd.c
display.o : display.c defs.h buffer.h
    cc -c display.c
insert.o : insert.c defs.h buffer.h
    cc -c insert.c
search.o : search.c defs.h buffer.h
    cc -c search.c
files.o : files.c defs.h buffer.h
    cc -c files.c
utils.o : utils.c defs.h
    cc -c utils.c
    
clean :
    rm edit main.o kbd.o display.o \
            insert.o search.o files.o utils.o
}}}

== Make如何工作 ==
{{{class="brush:text"
    默认的情况下,make执行的是Makefile中的第一个规则,此规则的第一个目标称之为“最终目的”或者“终极目标”。
    当在shell提示符下输入“make”命令以后。make读取当前目录下的Makefile文件,并将 Makefile 文件中的第一个目标作为其执行的“终极目标”,
开始处理第一个规则(终极目标所在的规则)。在我们的例子中,第一个规则就是目标“edit”所在的规则。规则描述了“edit”的依赖关系,并定义了链接.o
文件生成目标“edit”的命令; make在执行这个规则所定义的命令之前,首先处理目标“edit”的所有的依赖文件(例子中的那些.o文件)的更新规则
(以这些.o文件为目标的规则)。
    对这些.o文件为目标的规则处理有下列三种情况:
    1. 目标.o文件不存在,使用其描述规则创建它;
    2. 目标.o文件存在,目标.o文件所依赖的.c 源文件、文件中的任何一个比目标.o，.h文件“更新”(在上一次make之后被修改)。
则根据规则重新编译生成它;
    3. 目标.o文件存在,目标.o文件比它的任何一个依赖文件(的.c源文件、.h文件)“更新”(它的依赖文件在上一次make之后没有被修改),则什么也不做。
    这些.o文件所在的规则之所以会被执行,是因为这些.o文件出现在“终极目标”的依赖列表中。在Makefile中一个规则的目标如果不是“终极目标”
所依赖的(或者“终极目标”的依赖文件所依赖的),那么这个规则将不会被执行,除非明确指定执行这个规则(可以通过make的命令行指定重建目标,那么这个
目标所在的规则就会被执行,例如“make clean”)。在编译或者重新编译生成一个.o文件时,make同样会去寻找它的依赖文件的重建规则(是这样一个规则:
这个依赖文件在规则中作为目标出现)在这里就是.c和.h文件的重建规则。在上例的Makefile中没有哪个规则的目标是.c或者.h文件,所以没有重建.c和.h
文件的规则。不过C言语源程序文件可以使用工具Bison或者Yacc来生成(具体用法可参考相应的手册)。
}}}

== Makefile的变量 ==
- “objects”作为一个变量，它代表所有的.o文件的列表。
- 使用`$`符号引用一个变量。

{{{class="brush:bash"
objects = main.o kbd.o display.o \
            insert.o search.o files.o utils.o
            
edit : $(objects)
    cc -o edit $(objects)
.......

clean :
    rm edit $(objects)
}}}

=== 变量定义 ===
==== 递归展开式变量(=) ====
- 使用`=`来定义这种变量。这种变量的引用,在引用的地方是严格的文本替换过程,此变量值的字符串原模原样的出现在引用它的地方。如果此变量定义中存在对其他变量的引用,这些被引用的变量会在它被展开的同时被展开。就是说在变量定义时,变量值中对其他变量的引用不会被替换展开;而是变量在引用它的地方替换展开的同时,它所引用的其它变量才会被一同替换展开。

{{{class="brush:bash"
# bar可以在foo之后定义，并在引用到它的时候再展开
foo = $(bar)
bar = $(ugh)
ugh = Huh?

all:
    echo $(foo)
}}}

==== 直接展开式变量(:=) ====
- 这种风格的变量使用`:=`定义。在使用“:=”定义变量时,变量值中对其他量或者函数的引用在定义变量时被展开(对变量进行替换)。所以变量被定义后就是一个实际需要的文本串,其中不再包含任何变量的引用。
- 和递归展开式变量不同:此风格变量在定义时就完成了对所引用变量和函数的展开,因此不能实现对其后定义变量的引用。

{{{class="brush:bash"
x := foo
y := $(x) bar
x := later

# 等价于

y := foo bar
x := later
}}}

==== 条件赋值(?=) ====
- 还有一个被称为条件赋值的赋值操作符`?=`。被称为条件赋值是因为:只有此变量在之前没有赋值的情况下才会对这个变量进行赋值。

{{{class="brush:bash"
FOO ?= bar

# 等价于:
 
ifeq ($(origin FOO), undefined)
    FOO = bar
endif
}}}

==== 追加变量值(+=) ====
- 通常,一个通用变量在定义之后的其他一个地方,可以对其值进行追加。

{{{class="brush:bash"
objects = main.o foo.o bar.o utils.o
objects += another.o

#上边的两个操作之后变量“objects”的值就为:“main.o foo.o bar.o utils.o another.o”
}}}

=== 变量高级用法 ===
==== 变量的替换引用 ====
- 格式为`$(VAR:A=B)`(或者`${VAR:A=B}`),意思是替换变量“VAR”中所有“A”字符结尾的字为“B”结尾的字。

{{{class="brush:bash"
foo := a.o b.o c.o
bar := $(foo:%.o=%.c)

# 替换后“bar”的值为“a.c b.c c.c”
}}}

==== 变量的套嵌引用 ====
- 一个变量名(文本串)之中可以包含对其它变量的引用。这种情况我们称之为`变量的套嵌引用`或者`计算的变量名`。
- 计算的变量名在进行替换时的顺序是:从最里层的变量引用开始,逐步向外进行替换。一层层展开直到最后计算出需要应用的具体的变量,之后进行替换展开得到实际的引用值。

{{{class="brush:bash"
x=y
y=z
z=u
a := $($($(x)))

# 嵌套引用后“a”的值为“u”
}}}

== Makefile的函数 ==
- 通过关键字`define`定义一个函数。
- 函数的调用格式类似于变量的引用,以“$”开始表示一个引用。

{{{class="brush:text"
    1. 调用语法格式中“FUNCTION”是需要调用的函数名,它应该是make内嵌的函数名。对于用户自己的函数需要通过make语法的“call”函数来间接调用。
    2. “ARGUMENTS”是函数的参数,参数和函数名之间使用若干个空格或者[tab]字符分割(建议使用一个空格,这样不仅使在书写上比较直观,更重要的是当
你不能确定是否可以使用[Tab]的时候,避免不必要的麻烦);如果存在多个参数时,参数之间使用逗号“,”分开。
    3. 以“$”开头,使用成对的圆括号或花括号把函数名和参数括起(在 Makefile中,圆括号和花括号在任何地方必须成对出现)。
    4. 函数处理参数时,参数中如果存在对其它变量或者函数的引用,首先对这些引用进行展开得到参数的实际内容。而后才对它们进行处理。参数的展开顺序是
按照参数的先后顺序来进行的。
    5. 书写时,函数的参数不能出现逗号“,”和空格。这是因为逗号被作为多个参数的分隔符,前导空格会被忽略。在实际书写 Makefile 时,当有逗号或者空格作
为函数的参数时,需要把它们赋值给一个变量,在函数的参数中引用这个变量来实现。
    我们来看这样的例子：
    
    comma:= ,
    empty:=
    space:= $(empty) $(empty)
    foo:= a b c
    bar:= $(subst $(space),$(comma),$(foo))
}}}

{{{class="brush:bash"
#语法格式如下:
$(FUNCTION ARGUMENTS)
# 或者:
${FUNCTION ARGUMENTS}

# 函数的定义示例
define func
    echo $1
endef

# 函数的引用示例
$(func hello)
# 或者:
${func hello}
}}}

== 自动推导规则 ==
- 在使用make编译.c源文件时,编译.c源文件规则的命令可以不用明确给出。这是因为make本身存在一个默认的规则,能够自动完成对.c文件的编译并生成对应的.o文件。

{{{class="brush:bash"
#sample Makefile

objects = main.o kbd.o display.o \
            insert.o search.o files.o utils.o
edit : $(objects)
    cc -o edit $(objects)
    
$(objects) : defs.h
display.o insert.o search.o files.o : buffer.h
}}}

== 静态模式 ==
- 从目标模式`(TAGET-PATTERN)`的目标名字中抽取一部分字符串(称为“茎”，使用“茎”替代依赖模式`(PREREQ-PATTERNS)`中的相应部分来产生对)应目标的依赖文件。

{{{class="brush:bash"
objects = foo.o bar.o

all: $(objects)

$(objects): %.o: %.c
    $(CC) -c $(CFLAGS) $< -o $@
}}}

== 双冒号规则 ==
- 双冒号规则就是使用`::`代替普通规则的`:`得到的规则。
- Makefile 中,一个目标可以出现在多个规则中。但是这些规则必须是同一类型的规则,要么都是普通规则,要么都是双冒号规则。而不允许一个目标同时出现在两种不同类型的规则中。
- 双冒号规则和普通规则的处理的不同点表现在以下几个方面:

{{{class="brush:text"
    1. 双冒号规则中,当依赖文件比目标更新时。规则将会被执行。对于一个没有依赖而只有命令行的双冒号规则,当引用此目标时,
规则的命令将会被无条件执行。而普通规则,当规则的目标文件存在时,此规则的命令永远不会被执行(目标文件永远是最新的)。
    2. 当同一个文件作为多个双冒号规则的目标时。这些不同的规则会被独立的处理,而不是像普通规则那样合并所有的依赖到一个目标文件。
这就意味着对这些规则的处理就像多个不同的普通规则一样。就是说多个双冒号规则中的每一个的依赖文件被改变之后,make 只执行此规则定义
的命令,而其它的以这个文件作为目标的双冒号规则将不会被执行。
}}}

{{{class="brush:bash"
# 如果“foo.c”文件被修改,执行 make 以后将根据“foo.c”文件重建目标“Newprog”。
# 如果“bar.c”被修改那么“Newprog”将根据“bar.c”被重建。
Newprog :: foo.c
    $(CC) $(CFLAGS) $< -o $@
Newprog :: bar.c
    $(CC) $(CFLAGS) $< -o $@
}}}

== make执行过程总结 ==
- 依次读取变量“MAKEFILES”定义的makefile文件列表
- 读取工作目录下的makefile文件(根据命名的查找顺序“GNUmakefile”，“makefile”“Makefile”，首先找到那个就读取那个)
- 依次读取工作目录makefile文件中使用指示符“include”包含的文件
- 查找重建所有已读取的makefile文件的规则(如果存在一个目标是当前读取的某一个makefile 文件,则执行此规则重建此 makefile 文件,完成以后从第一步开始重新执行)
- 初始化变量值并展开那些需要立即展开的变量和函数并根据预设条件确定执行分支
- 根据“终极目标”以及其他目标的依赖关系建立依赖关系链表
- 执行除“终极目标”以外的所有的目标的规则(规则中如果依赖文件中任一个文件的时间戳比目标文件新,则使用规则所定义的命令重建目标文件)
- 执行“终极目标”所在的规则

=== 执行一个规则的过程 ===
{{{class="brush:text"
    对于一个存在的规则(明确规则和隐含规则)首先,make程序将比较目标文件和所有的依赖文件的时间戳。
如果目标的时间戳比所有依赖文件的时间戳更新(依赖文件在上一次执行make之后没有被修改),那么什么也不做。
否则(依赖文件中的某一个或者全部在上一次执行make后已经被修改过)，规则所定义的重建目标的命令将会被执行。
这就是make工作的基础,也是其执行规则所定义命令的依据。
}}}

