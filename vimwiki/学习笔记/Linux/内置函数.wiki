= 内置函数集 =

%toc

== 文本处理函数 ==
=== $(subst FROM,TO,TEXT) ===
函数名称 :: 字符串替换函数—subst。
函数功能 :: 把字串“TEXT”中的“FROM”字符替换为“TO”。
返回值 :: 替换后的新字符串。
示例 ::
{{{class="brush:bash"
# 替换“feet on the street” “ee” “EE” 结果得到字符串中的为,“fEEt on the strEEt”。
$(subst ee,EE,feet on the street)
}}}

=== $(patsubst PATTERN,REPLACEMENT,TEXT) ===
函数名称 :: 模式替换函数—patsubst。
函数功能 :: 搜索“TEXT”中以空格分开的单词,将否符合模式“TATTERN”替换为“REPLACEMENT”。参数“PATTERN”中可以使用模式通配符“%”来代表一个单词中的若干字符。
返回值 :: 替换后的新字符串。
函数说明 :: 参数“TEXT”单词之间的多个空格在处理时被合并为一个空格,并忽略前导和结尾空格。
示例 ::
{{{class="brush:bash"
# 把字串“x.c.c bar.c”中以.c 结尾的单词替换成以.o 结尾的字符。函数的返回结果是“x.c.o bar.o”。
$(patsubst %.c,%.o,x.c.c bar.c)
}}}

=== $(strip STRINT) ===
函数名称 :: 去空格函数—strip。
函数功能 :: 去掉字串(若干单词,使用若干空字符分割)“STRINT”开头和结尾的空字符,并将其中多个连续空字符合并为一个空字符。
返回值 :: 无前导和结尾空字符、使用单一空格分割的多单词字符串。
函数说明 :: 空字符包括空格、[Tab]等不可显示字符。“strip”函数经常用在条件判断语句的表达式中,确保表达式比较的可靠和健壮!
示例 ::
{{{class="brush:bash"
# 结果返回"abc"
STR = a b c
LOSTR = $(strip $(STR))
}}}

=== $(findstring FIND,TEXT) ===
函数名称 :: 查找字符串函数—findstring。
函数功能 :: 搜索字串“TEXT”,查找“FIND”字串。
返回值 :: 如果在“TEXT”之中存在“FIND”,则返回“FIND”,否则返回空。
函数说明 :: 字串“TEXT”之中可以包含空格、[Tab]。搜索需要是严格的文本匹配。
示例 ::
{{{class="brush:bash"
# 第一个函数结果是字“a”;第二个值为空字符。
$(findstring a,a b c)
$(findstring a,b c)
}}}

=== $(filter PATTERN...,TEXT) ===
函数名称 :: 过滤函数—filter。
函数功能 :: 过滤掉字串“TEXT”中所有不符合模式“PATTERN”的单词,保留所有符合此模式的单词。可以使用多个模式。模式中一般需要包含模式字符“%”。存在多个模式时,模式表达式之间使用空格分割。
返回值 :: 空格分割的“TEXT”字串中所有符合模式“PATTERN”的字串。
函数说明 :: filter”函数可以用来去除一个变量中的某些字符串,我们下边的例子中就是用到了此函数。
示例 ::
{{{class="brush:bash"
# 使用“$(filter %.c %.s,$(sources))”的返回值给cc来编译生成目标“foo”,函数返回值为“foo.c bar.c baz.s”。
sources := foo.c bar.c baz.s ugh.h
foo: $(sources)
    cc $(filter %.c %.s,$(sources)) -o foo
}}}

=== $(filter-out PATTERN...,TEXT) ===
函数名称 :: 反过滤函数—filter-out。
函数功能 :: 和“filter”函数实现的功能相反。过滤掉字串“TEXT”中所有符合模式“PATTERN”的单词,保留所有不符合此模式的单词。可以有多个模式。存在多个模式时,模式表达式之间使用空格分割。
返回值 :: 空格分割的“TEXT”字串中所有不符合模式“PATTERN”的字串。
函数说明 :: filter-out”函数也可以用来去除一个变量中的某些字符串,(实现和“filter”函数相反)。
示例 ::
{{{class="brush:bash"
# 实现了去除变量“objects”中“mains”定义的字串(文件名)功能。它的返回值为“foo.o bar.o”。
objects = main1.o foo.o main2.o bar.o
mains = main1.o main2.o
$(filter-out $(mains),$(objects))
}}}

=== $(sort LIST) ===
函数名称 :: 排序函数—sort。
函数功能 :: 给字串“LIST”中的单词以首字母为准进行排序(升序),并取掉重复的单词。
返回值 :: 空格分割的没有重复单词的字串。
函数说明 :: 两个功能,排序和去字串中的重复单词。可以单独使用其中一个功能。
示例 ::
{{{class="brush:bash"
# 返回值为:“bar foo lose” 。
$(sort foo bar lose foo)
}}}

=== $(word N,TEXT) ===
函数名称 :: 取单词函数—word。
函数功能 :: 取字串“TEXT”中第“N”个单词(“N”的值从 1 开始)。
返回值 :: 返回字串“TEXT”中第“N”个单词。
函数说明 :: 如果“N”值大于字串“TEXT”中单词的数目,返回空字符串。如果“N”为0,出错!
示例 ::
{{{class="brush:bash"
# 返回值为“bar”
$(word 2, foo bar baz)
}}}

=== $(wordlist S,E,TEXT) ===
函数名称 :: 取字串函数—wordlist。
函数功能 :: 从字串“TEXT”中取出从“S”开始到“E”的单词串。“S”和“E”表示单词在字串中位置的数字。
返回值 :: 字串“TEXT”中从第“S”到“E”(包括“E”)的单词字串。
函数说明 :: S”和“E”都是从 1 开始的数字。当“S”比“TEXT”中的字数大时,返回空。如果“E”大于“TEXT”字数,返回从“S”开始,到“TEXT”结束的单词串。如果“S”大于“E”,返回空。
示例 ::
{{{class="brush:bash"
# 返回值为:“bar baz”。
$(wordlist 2, 3, foo bar baz)
}}}

=== $(words TEXT) ===
函数名称 :: 统计单词数目函数—words。
函数功能 :: 字算字串“TEXT”中单词的数目。
返回值 :: “TEXT”字串中的单词数。
示例 ::
{{{class="brush:bash"
# 返回值是“2”所以字串“TEXT”的最后一个单词就是:$(word $(words TEXT),TEXT)。
$(words, foo bar)
}}}

=== $(firstword NAMES...) ===
函数名称 :: 取首单词函数—firstword。
函数功能 :: 取字串“NAMES...”中的第一个单词。
返回值 :: 字串“NAMES...”的第一个单词。
函数说明 :: “NAMES”被认为是使用空格分割的多个单词(名字)的序列。函数忽略“NAMES...”中除第一个单词以外的所有的单词。
示例 ::
{{{class="brush:bash"
# 返回值为“foo”。函数“firstword”实现的功能等效于“$(word 1, NAMES...)”。
$(firstword foo bar)
}}}

== 文件名处理函数 ==
=== $(dir NAMES...) ===
函数名称 :: 取目录函数—dir。
函数功能 :: 从文件名序列“NAMES...”中取出各个文件名的目录部分。文件名的目录部分就是包含在文件名中的最后一个斜线`“/”(包括斜线)`之前的部分。
返回值 :: 空格分割的文件名序列“NAMES...”中每一个文件的目录部分。函数说明:如果文件名中没有斜线,认为此文件为当前目录(“./”)下的文件。
示例 ::
{{{class="brush:bash"
# 返回值为“src/ ./”。
$(dir src/foo.c hacks)
}}}

=== $(notdir NAMES...) ===
函数名称 :: 取文件名函数——notdir。
函数功能 :: 从文件名序列“NAMES...”中取出非目录部分。目录部分是指最后一个斜线`“/”(包括斜线)`之前的部分。删除所有文件名中的目录部分,只保留非目录部分。
返回值 :: 文件名序列“NAMES...”中每一个文件的非目录部分。
函数说明 :: 如果“NAMES...”中存在不包含斜线的文件名,则不改变这个文件名。以反斜线结尾的文件名,是用空串代替,因此当“NAMES...”中存在多个这样的文件名时,返回结果中分割各个文件名的空格数目将不确定!这是此函数的一个缺陷。
示例:
{{{class="brush:bash"
# 返回值为:“foo.c hacks”。
$(notdir src/foo.c hacks)
}}}

=== $(suffix NAMES...) ===
函数名称 :: 取后缀函数—suffix。
函数功能 :: 从文件名序列“NAMES...”中取出各个文件名的后缀。后缀是文件名中最后一个以点`“.”开始的(包含点号)`部分,如果文件名中不包含一个点号,则为空。
返回值 :: 以空格分割的文件名序列“NAMES...”中每一个文件的后缀序列。
函数说明 :: “NAMES...”是多个文件名时,返回值是多个以空格分割的单词序列。如果文件名没有后缀部分,则返回空。
示例 ::
{{{class="brush:bash"
# 返回值为“.c .c”
$(suffix src/foo.c src-1.0/bar.c hacks)
}}}

=== $(basename NAMES...) ===
函数名称 :: 取前缀函数—basename。
函数功能 :: 从文件名序列“NAMES...”中取出各个文件名的前缀部分`(点号之后的部分)`。前缀部分指的是文件名中最后一个点号之前的部分。
返回值 :: 空格分割的文件名序列“NAMES...”中各个文件的前缀序列。如果文件没有前缀,则返回空字串。
函数说明 :: 如果“NAMES...”中包含没有后缀的文件名,此文件名不改变。如果一个文件名中存在多个点号,则返回值为此文件名的最后一个点号之前的文件名部分。
示例 ::
{{{class="brush:bash"
# 返回值为:“src/foo src-1.0/bar /home/jack/.font hacks”。
$(basename src/foo.c src-1.0/bar.c /home/jack/.font.cache-1 hacks)
}}}

=== $(addsuffix SUFFIX,NAMES...) ===
函数名称 :: 加后缀函数—addsuffix。
函数功能 :: “NAMES...”为中的每一个文件名添加后缀“SUFFIX”。参数“NAMES...”为空格分割的文件名序列,将“SUFFIX”追加到此序列的每一个文件名的末尾。
返回值 :: 以单空格分割的添加了后缀“SUFFIX”的文件名序列。
示例 ::
{{{class="brush:bash"
# 返回值为“foo.c bar.c”。
$(addsuffix .c,foo bar)
}}}

=== $(addprefix PREFIX,NAMES...) ===
函数名称 :: 加前缀函数—addprefix。
函数功能 :: “NAMES...”为中的每一个文件名添加前缀“PREFIX”。参数“NAMES...”是空格分割的文件名序列,将“SUFFIX”添加到此序列的每一个文件名之前。
返回值 :: 以单空格分割的添加了前缀“PREFIX”的文件名序列。
示例 ::
{{{class="brush:bash"
# 返回值为“src/foo src/bar”。
$(addprefix src/,foo bar)
}}}

=== $(join LIST1,LIST2) ===
函数名称 :: 单词连接函数——join。
函数功能 :: 将字串“LIST1”和字串“LIST2”各单词进行对应连接。就是将“LIST2”中的第一个单词追加“LIST1”第一个单词字后合并为一个单词;将 “LIST2”中的第二个单词追加到“LIST1”的第一个单词之后并合并为一个单词,......依次列推。
返回值 :: 单空格分割的合并后的字(文件名)序列。
函数说明 :: 如果“LIST1”和“LIST2”中的字数目不一致时,两者中多余部分将被作为返回序列的一部分。
示例 ::
{{{class="brush:bash"
# 示例1返回值为: “a.c b.o”。
$(join a b , .c .o)

# 示例2返回值为:“a.c b.o c”。
$(join a b c , .c .o)
}}}

=== $(wildcard PATTERN) ===
函数名称 :: 获取匹配模式文件名函数—wildcard
函数功能 :: 列出当前目录下所有符合模式“PATTERN”格式的文件名。
返回值 :: 空格分割的、存在当前目录下的所有符合模式“PATTERN”的文件名。
函数说明 :: “PATTERN”使用shell可识别的通配符,包括`“?”(单字符)`、`“*”(多字符)`等。
示例 ::
{{{class="brush:bash"
# 返回值为当前目录下所有.c 源文件列表。
$(wildcard *.c)
}}}

== 逻辑处理函数 ==
=== $(foreach VAR,LIST,TEXT) ===
函数名称 :: 循环遍历——foreach
函数功能 :: 这个函数的工作过程是这样的:如果需要(存在变量或者函数的引用),首先展开变量“VAR”和“LIST”的引用;而表达式“TEXT”中的变量 引用不展开。执行时把“LIST”中使用空格分割的单词依次取出赋值给变量“VAR”,然后执行“TEXT”表达式。重复直到“LIST”的最后一个单词(为空时结束)。 “TEXT”中的变量或者函数引用在执行时才被展开,因此如果在“TEXT”中存在对“VAR”的引用,那么“VAR”的值在每一次展开式将会到的不同的值。
返回值 :: 空格分割的多次表达式“TEXT”的计算的结果。
函数说明 :: 函数中参数“VAR”是一个局部的临时变量,它只在“foreach”函数的上下文中有效,它的定义不会影响其它部分定义的同名“VAR”变量的值。在函数的执行过程中它是一个“直接展开”式变量。
示例 ::
{{{class="brush:bash"
dirs := a b c d
files := $(foreach dir,$(dirs),$(wildcard $(dir)/*))
}}}

=== $(if CONDITION,THEN-PART[,ELSE-PART]) ===
函数名称 :: 条件判断——if
函数功能 :: 第一个参数“CONDITION”,在函数执行时忽略其前导和结尾空字符,如果包含对其他变量或者函数的引用则进行展开。如果“CONDITION”的展开结果非空,则条件为真,就将第二个参数“THEN_PATR”作为函数的计算表达式;“CONDITION”的展开结果为空,将第三个参数“ELSE-PART”作为函数的表达式,函数的返回结果为有效表达式的计算结果。
返回值 :: 根据条件决定函数的返回值是第一个或者第二个参数表达式的计算结果。当不存在第三个参数“ELSE-PART”,并且“CONDITION”展开为空,函数返回空。
函数说明 :: 函数的条件表达式“CONDITION”决定了函数的返回值只能是“THEN-PART”或者“ELSE-PART”两个之一的计算结果。
示例 ::
{{{class="brush:bash"
# 函数的结果是:如果“SRC_DIR”变量值不为空,则将变量“SRC_DIR”指定的目录作为一个子目录;否则将目录“/home/src”作为一个子目录。
SUBDIR += $(if $(SRC_DIR),$(SRC_DIR),/home/src)
}}}

=== $(call VARIABLE,PARAM,PARAM,...) ===
函数名称 :: 函数引用——call
函数功能 :: 在执行时,将它的参数“PARAM”依次赋值给临时变量“$(1)”“$(2)”、(这些临时变量定义在“VARIABLE”的值中,参考下边的例子)...... call 函数对参数的数目没有限制,也可以没有参数值,没有参数值的“call”没有任何实际存在的意义。执行时变量“VARIABLE”被展开为在函数上下文有效的临时变量,变量定义中的“$(1)”作为第一个参数,并将函数参数值中的第一个参数赋值给它;变量中的“$(2)”一样被赋值为函数的第二个参数值;依此类推(变量$(0)代表变量“VARIABLE”本身)。之后对变量“VARIABLE” 表达式的计算值。
返回值 :: 参数值“PARAM”依次替换“$(1)”“$(2)”、...... 之后变量“VARIABLE”定义的表达式的计算值。
函数说明 :: 1. 函数中“VARIBLE”是一个变量名,而不是变量引用。因此,通常“call”函数中的“VARIABLE”中不包含“$”(当然,除非此变量名是一个计算的变量名) 2. 当变量。“VARIBLE”是一个make内嵌的函数名时(如“if”、“foreach”“strip”等)、,对“PARAM”参数的使用需要注意,因为不合适或者不正确的参数将会导致函数的返回值难以预料。3. 函数中多个“PARAM”之间使用逗号分割。4. 变量“VARIABLE”在定义时不能定义为直接展开式!只能定义为递归展开式。函数示例
示例 :: 
{{{class="brush:bash"
# 示例 1:
reverse = $(2) $(1)
foo = $(call reverse,a,b)

# 示例 2:
pathsearch = $(firstword $(wildcard $(addsuffix /$(1),$(subst :, ,$(PATH)))))
LS := $(call pathsearch,ls)

# 示例 3:
map = $(foreach a,$(2),$(call $(1),$(a)))
o = $(call map,origin,o map MAKE)
}}}

=== $(value VARIABLE) ===
函数名称 :: 变量名取值——value
函数功能 :: 不对变量“VARIBLE”进行任何展开操作,直接返回变量“VARIBALE”的值。这里“VARIABLE”是一个变量名,一般不包含“$”(除非计算的变量名)．
返回值 :: 变量“VARIBALE”所定义文本值(如果变量定义为递归展开式,其中包含对其他变量或者函数的引用,那么函数不对这些引用进行展开。函数的返回值是包含有引用值)。
函数说明 :: 
示例 ::
{{{class="brush:bash"
# sample Makefile
FOO = $PATH
all:
    @echo $(FOO)
    @echo $(value FOO)
}}}

=== $(eval EXPRESS) ===
函数名称 :: eval
函数功能 :: 函数“eval”是一个比较特殊的函数。使用它可以在Makefile中构造一个可变的规则结构关系(依赖关系链),其中可以使用其它变量和函数。函数“eval”对它的参数进行展开,展开的结果作为Makefile的一部分,make可以对展开内容进行语法解析。展开的结果可以包含一个新变量、目标、隐含规则或者是明确规则等。也就是说此函数的功能主要是:根据其参数的关系、结构,对它们进行替换展开。
返回值 :: 函数“eval”的返回值时空,也可以说没有返回值。
函数说明 :: “eval”函数执行时会对它的参数进行两次展开。第一次展开过程发是由函数本身完成的,第二次是函数展开后的结果被作为Makefile内容时由make解析时展开的。明确这一过程对于使用“eval”函数非常重要。理解了函数“eval”二次展开的过程后。实际使用时,如果在函数的展开结果中存在引用(格式为:$(x)) 那么在函数的参数中应该使用,“$$”来代替“$”。
示例 ::
{{{class="brush:bash"
define PROGRAM_template
    $(1): $$($(1)_OBJ) $$($(1)_LIBS:%=-l%)
    ALL_OBJS += $$($(1)_OBJS)
endef

$(foreach prog,$(PROGRAMS),$(eval $(call PROGRAM_template,$(prog))))
}}}

=== $(origin VARIABLE) ===
函数名称 :: 变量名出处——origin
函数功能 :: 函数“origin”查询参数“VARIABLE”(一个变量名)的出处。
函数说明 :: “VARIABLE”是一个变量名而不是一个变量的引用。因此通常它不包含“$”(当然,计算的变量名例外)。
返回值 :: 返回“VARIABLE”的定义方式。用字符串表示。函数的返回情况有以下几种:
{{{class="brush:bash"
1. undefined
变量“VARIABLE”没有被定义。

2. default
变量“VARIABLE”是一个默认定义(内嵌变量)。如“CC”、“MAKE”、“RM”等变量。如果在Makefile中重新定义这些变量,
函数返回值将相应发生变化。

3. environment
变量“VARIABLE”是一个系统环境变量,并且make没有使用命令行选项“-e”(Makefile中不存在同名的变量定义,此变量没有被替代)。

4. environment override
变量“VARIABLE”是一个系统环境变量,并且make使用了命令行选项“-e”。Makefile中存在一个同名的变量定义,使用“make -e”
时环境变量值替代了文件中的变量定义。

5. file
变量“VARIABLE”在某一个makefile文件中定义。

6. command line
变量“VARIABLE”在命令行中定义。

7. override
变量“VARIABLE”在makefile文件中定义并使用“override”指示符声明。

8. automatic
变量“VARIABLE”是自动化变量。
}}}

示例 ::
{{{class="brush:bash"
ifdef bletch
    ifeq "$(origin bletch)" "environment"
        bletch = barf, gag, etc.
    endif
endif
}}}

=== $(shell command...) ===
函数名称 :: 运行shell命令——shell
函数功能 :: 函数“shell”所实现的功能和shell中的引用(``)相同。实现对命令的扩展。这就意味着需要一个shell命令作为此函数的参数,函数的返回结果是此命令在shell中的执行结果。make仅仅对它的回返结果进行处理;make将函数返回结果中的所有换行符(“\n”)或者一对“\n\r”替换为单空格;并去掉末尾的回车符号(“\n”)或者“\n\r”。
返回值 :: 函数“shell”的参数(一个 shell 命令)在 shell 环境中的执行结果。
函数说明 :: 函数本身的返回值是其参数的执行结果,没有进行任何处理。对结果的处理是由 make 进行的。当对函数的引用出现在规则的命令行中,命令行在执行时函数才被展开。展开时函数参数(shell 命令)的执行是在另外一个shell进程中完成的,因此需要对出现在规则命令行的多级“shell”函数引用需要谨慎处理,否则会影响效率(每一级的“shell”函数的参数都会有各自的shell进程)。
示例 ::
{{{class="brush:bash"
# 示例 1:
# 将变量“contents”赋值为文件“foo”的内容,文件中的换行符在变量中使用空格代替。
contents := $(shell cat foo)

# 示例 2:
# 将变量“files”赋值为当前目录下所有.c文件的列表(文件名之间使用空格分割)
files := $(shell echo *.c)
}}}

== 控制函数 ==
=== $(error TEXT...) ===
函数名称 :: 错误提示——error
函数功能 :: 产生致命错误,并提示“TEXT...”信息给用户,并退出make的执行。需要说明的是:“error”函数是在函数展开式(函数被调用时)才提示信息并结束make 进程。因此如果函数出现在命令中或者一个递归的变量定义中时,在读取 Makefile 时不会出现错误。而只有包含“error”函数引用的命令被执行,或者定义中引用此函数的递归变量被展开时,才会提示致命信息“TEXT...”同时退出 make。
返回值 :: 空
函数说明 :: “error”函数一般不出现在直接展开式的变量定义中,否则在make读取Makefile时将会提示致命错误。
示例 ::
{{{class="brush:bash"
# 示例 1:
ifdef ERROR1
    $(error error is $(ERROR1))
endif

# 示例 2:
ERR = $(error found an error!)
.PHONY: err
err: ; $(ERR)
}}}

=== $(warning TEXT...) ===
函数名称 :: 警告提示——warining
函数功能 :: 函数“warning”类似于函数“error”,区别在于它不会导致致命错误(make不退出),而只是提示“TEXT...”,make 的执行过程继续。
返回值 :: 空
函数说明 :: 用法和“error”类似,展开过程相同。


